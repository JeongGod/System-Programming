# 설계
### 초기에는 execvp를 이용한 간단한 명령어가 계속해서 입력을 받아지는지에 대한 설계
1. 명령어를 입력 받으면, `fork`를 통해 자식프로세스를 생성해 명령어를 수행시키게 한 뒤, `execvp`를 통해 종료.
2. 부모(메인)은 그 자식들이 종료될 때 까지 `waitpid` 함수로 기다린다.
---------------------------
### 여러개의 명령어를 수행
1. ";"를 자르기 위해 `strtok`함수로 잘라내었다. 이 때, 띄어쓰기도 잘라야 하기에 '\t'도 같이 잘라내었다.
2. 그 뒤에 명령어를 수행시켰다.
--------------------------
### history 구현
1. history는 쉘이 꺼진 뒤에도 그 기록들이 남아있어야 했다.   
 => 그래서 파일로 명령어들을 저장해두어 쉘이 꺼진 뒤에도 기록이 유지되게끔 하였다.
2. index도 주어야 한다.   
 => '\n'의 숫자를 세어 index를 부여하였다.
3. `!{history_index}` 를 실행하면 명령어 실행
--------------------------
### '>|', '>', '>>', '<' 구현
1. file_name을 `strtok`함수로 뽑은 뒤, 명령어에 따라 read, write를 한다.
--------------------------
### 설정
1. set +o noclobber를 하면 '>' 명령어는 불가, '>|'만 가능하다.
--------------------------
### pipe 구현
```
ls | grep ^d | wc
```
1. 위와 같은 명령어가 들어온다면 ls -> grep ^d -> wc 순으로 실행 및 결과를 반환하여 이루어진다.
2. 맨 마지막이 부모고 나머지는 다 자식인 것으로 구현
--------------------------
### Background 구현
1. `&{command}` 가 들어온다면 부모는 `waitpid`를 하지 않아 background로 돌게 만든다..